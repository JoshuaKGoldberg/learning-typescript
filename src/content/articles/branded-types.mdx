---
date: "August 04 2024"
description: "How the concept of branded types allows describing primitives more precisely than TypeScript normally allows."
meta: arguments, functions, parameters, rest, spread, tuples, unions
---

# Branded Types

TypeScript's structural type system allows any two types that seem to have the same shape to be assignable to each other.
But what if you want to restrict a type to only allow certain values, even if other values happen to have the same structure?
Say, marking a difference between sanitized and un-sanitized strings, or positive integers from all numbers?

This need is solveable with a pattern called _"branded types"_, sometimes also called _"opaque types"_.
Let's dive into why you'd want to revert back to "nominal" typing with branded types, how to declare and use brand types, and some alternatives to the pattern.

{/* <!-- truncate --> */}

## Branding Needs

TypeScript's type system doesn't always provide a way to differentiate types that seem to be structurally the same.
For example, some values in application might need to work only with positive numbers.
Assigning any number that isn't known to be zero or positive should be a type error:

```ts
declare function waitForSeconds(seconds: number): Promise<void>;

async function waitThenLog(seconds: number) {
  // This should be an error: -1 is not positive. üëé
  console.log(waitForSeconds(-1));

  // This should not be an error. üëç
  console.log(waitForSeconds(seconds));

  console.log("Done!");
}
```

We need a way to tell TypeScript that there is a classification of numbers that are specifically known to be positive.
In other words, we need a way to _"brand"_ (mark) some number as being not just any old number, but specifically the type we want.

### Introducing Branded Types

A _"branded type"_ is one that is he same as an existing type, but with some extra type system property that doesn't actually exist at runtime.
That _"brand"_ property is used to differentiate the two types in the type system.

As an example, we can declare a branded type for positive numbers by declaring a `Positive` type that is both a `number` and an object with a never-used `__brand` property.
The values we'll later use as `Positive`s won't actually have a `__brand`.
The `__brand` property is just in the type system.

We can then use that `Positive` branded type in place of `number` for any location that should only ever receive a positive number:

```ts twoslash
// @errors: 2345
type Positive = number & { __brand: "positive" };

declare function waitForSeconds(seconds: Positive): Promise<void>;

async function waitThenLog(seconds: Positive) {
  // Now, this errors as we'd expect it to. üëç
  console.log(waitForSeconds(-1));

  // This should not be an error: a guid is being used. üëç
  console.log(waitForSeconds(seconds));

  console.log("Done!");
}
```

By marking our guid numbers as the `Positive` type, we indicated to TypeScript that non-positive numbers shouldn't be used in their place.
In doing so we achieved more safety in our code - at the cost of writing a few more types.

Branded types are a useful lie to the type system: our positive numbers will never actually have that `__brand` property.
We're just making sure that no developer accidentally provides a value of a non-branded type to a location that requires one that is branded.

## Branding Values

The previous code showed passing around values that are already known to be a branded type.
But what about using a new value that is known to a branded type?

Creating a new value that is used as a branded type generally requires asserting to TypeScript that the value does, in fact, satisfy the branded type's guarantees.
This is often done in one of two ways: with an `as` assertion or with a utility function.

### `as` Assertions

Type assertions are a way of telling TypeScript something it wouldn't be able to know from code on its own.
In the case of branded values, `as` can be used to tell TypeScript that a value is intended to be an instance of a branded type.

The following snippet uses an `as` assertion to tell TypeScript that the `123` is, in fact, a `Positive`:

```ts twoslash
// @errors: 2322
type Positive = number & { __brand: "positive" };

let myPositive: Positive;

// Ok: the assertion tells TypeScript we meant this. üëç
myPositive = 123 as Positive;

// Type error: TypeScript doesn't know whether this is intended.
myPositive = 123;
```

By using an `as` assertion, the code told TypeScript that the `123` value should be considered a `Positive`.
Notice that no `__brand` property was ever assigned at runtime.
The `as` assertion told TypeScript to assume it exists.

Using `as` assertions for branded types is a convenient way to quickly assert a value to be a branded type.
Unfortunately, `as` assertions can bypass type errors in cases where the developer might not be correct.
The previous code could have written something blatantly incorrect, like `-1 as Positive`, and TypeScript would have been none the wiser.

Be very careful whenever using `as` assertions in TypeScript.

### Type Predicates

Instead of writing `as` assertions to create new instances of branded types, it's often safer -though more laborious- to use functions that validate values before they can be considered instances of branded types.

_"Type predicates"_ are functions whose return type indicates whether a parameter `is` a particular type.
Although they return a `boolean` value at runtime, the type system knows to apply type narrowing based on the returned value.

Type predicates can be used to return whether a parameter `is` a particular branded type.

This `isPositive` returns a `boolean` indicating whether `value is Positive`.
That means inside of the following `if (isPositive(value)) {`, TypeScript knows the `value` is of type `Positive`:

```ts twoslash
// @errors: 2322
type Positive = number & { __brand: "positive" };

function isPositive(value: number): value is Positive {
  return value > 0;
}

let myPositive: Positive;

let value = 123;
//  ^?

if (isPositive(value)) {
  // Ok: the type predicate tells TypeScript we meant this. üëç
  myPositive = value;
  //           ^?
}

// Type error: TypeScript doesn't know whether this is intended.
myPositive = 123;
```

Type predicates can be useful for safely gating some logic on whether a value matches a branded type's intent.
But, keep in mind that type predicates aren't much more type-safe than an `as` assertion.
TypeScript doesn't check whether the logic of a type predicate matches up to a branded type's intent.
It leaves that up to the code author.

### Type Assertion Functions

Another downside of type predicate functions is that they require writing conditional wrappers in code (the `if (isPositive) { ... }`).
Those `if`s take up more space and add more runtime logic than `as` assertions.

To make our code a little more readable, we can extract a utility function known as a _"type assertion function"_.
A type assertion function takes in a value, throws an error if the value doesn't match an expected type, and otherwise returns the value.
When paired with a type predicate function, a type assertion function can inform TypeScript's type system that a value is an instance of a branded type.

This `asPositive` function uses `isPositive` to throw an error if the value isn't an integer.
The result is that calling code can wrap a value with `asPositive` to assert that that value is, in fact, an `Positive`:

```ts twoslash
// @errors: 2322
type Positive = number & { __brand: "positive" };

function isPositive(value: number): value is Positive {
  return value > 0;
}

function asPositive(value: number): Positive {
  if (!isPositive(value)) {
    throw new Error(`${value} is not positive.`);
  }

  return value;
}

let myPositive: Positive;

// Ok: the type predicate tells TypeScript we meant this. üëç
myPositive = asPositive(123);

// Type error: TypeScript doesn't know whether this is intended.
myPositive = 123;
```

Type assertion functions can be a handy pattern for writing more succinct code with branded types.
However, they introduce a new downside of relying on throwing errors to indicate when values aren't the correct type.
[Thrown errors can't be made type-safe](./why-typescript-doesnt-include-a-throws-keyword.mdx).

Be very careful whenever using type assertion functions in TypeScript.

## Uses for Branded Types

Branded types can be handy whenever TypeScript should be told that two seemingly-identical structures are actually different.
The following three sections are are non-exhaustive list of use cases for branded types.

### Numbers

Numbers are some of the most common uses for branded types because TypeScript doesn't support numeric types more specific than `bigint` or `integer`.
Existing proposals such as [Microsoft/TypeScript#54925](https://github.com/microsoft/TypeScript/issues/54925) are still in discussion.

Other general variants: `Negative`, `NonZero`, `Prime`, and so on can all be represented with branded types.

Currency handling is another useful case.
Applications dealing with multiple currencies might need to make sure numbers used for amounts of one currency don't accidentally get transferred to a different currency.

This code uses a generic `Currency<T>` type to set up multiple branded types for currencies:

```ts twoslash
// @errors: 2322
type Currency<T> = number & { __currency: T };
type Euro = Currency<"euro">;
type USD = Currency<"usd">;

interface PurchasableEuro {
  cost: Euro;
  name: string;
}

const myPrice = 10 as USD;

const gyro: PurchasableEuro = {
  cost: myPrice,
  name: "euro",
};
```

:::note
Per [Microsoft/TypeScript#59423 Don't allow math operations on different branded numeric types](https://github.com/microsoft/TypeScript/issues/59423), binary operations on branded numeric types don't cause any type errors.
Use with caution.
:::

### Strings

Other uses for branded string types include decoded or sanitized text, such as user input that has been sanitized against injected code, passwords, and HTML or URL encoded characters.

This snippet helps protect against [XSS attacks](https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting) by forcing user input to be sanitized before appending to the DOM:

```ts twoslash
// @errors: 2345
type SafeString = string & { __sanitized: true };

/**
 * Removes any unsafe parts, such as <script> tags
 */
declare function sanitize(xml: string): SafeString;

function writeToDocument(xml: SafeString) {
  document.body.innerHTML += xml;
}

const userInput = `<script src="evil.js"></script>`;

// Ok: the text is sanitized and safe for the page üëç
writeToDocument(sanitize(userInput));

// Type error: unsafe input XML üëé
writeToDocument(userInput);
```

:::note
[Writing to `innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML#replacing_the_contents_of_an_element) is a dangerous practice in general.
Treat this as an educational example, not an endorsement of insecure HTML practices.
:::

Strings can also be used as "guid" (Globally Unique ID) types or similar identifying properties in code.
Some applications declare branded GUID types for every shape of data in their database, to ensure they can't be interchanged with each other.

This snippet differentiates comment IDs and post IDs with branded `Guid` types:

```ts twoslash
// @errors: 2345
type Guid<DataType> = string & { __guid: DataType };

type CommentId = Guid<"comment">;
type PostId = Guid<"post">;

interface Comment {
  id: CommentId;
  // ...
}

interface Post {
  id: PostId;
  // ...
}

declare function getCommentById(id: CommentId): Promise<Comment>;
declare function getPostById(id: PostId): Promise<Post>;

async function getById(id: CommentId) {
  // Ok: the branded type matches up üëç
  await getCommentById(id);

  // Type error: mismatched comment and post üëé
  await getPostById(id);
}
```

### Objects

Branded types can be used with any form of data in TypeScript, not just primitives.
If different values outside of your control have the same shape, you can use a branded type to differentiate them.

In the following snippet, the deprecated `searchApi` function happens to returns the same data shape as the newer `searchApiV2`.
The `Result` interface is given a `__version` brand to ensure that the correct version of results are used in the `results` variable:

```ts twoslash
// @errors: 2322
// @lib: esnext
// @target: esnext
export {};
// ---cut---
interface Result<Version> {
  query: string;
  results: string[];
  __version: Version;
}

type ResultV1 = Result<1>;
type ResultV2 = Result<2>;

/** @deprecated Prefer @see {searchApiV2}. */
declare function searchApiV1(query: string): Promise<ResultV1>;

declare function searchApiV2(query: string): Promise<ResultV2>;

let results: ResultV2;

// Ok: the branded type matches up üëç
results = await searchApiV2("");

// Type error: mismatched result version üëé
results = await searchApiV1("");
```

Branded object types are fairly rare in TypeScript code.
It's generally easier to use real properties on the objects that exist at runtime.
See [Discriminated Unions](#discriminated-unions) later for an alternative.

## Community Libraries

Branded types aren't used in most TypeScript projects, but they are handy enough that a few community projects have sprung up to make using them easier.
`ts-brand` and Effect TS are two of the more popular ones.

### `ts-brand`

The [`ts-brand`](https://github.com/kourge/ts-brand) package provides a community-built option to share pre-written code just for type brands.
It exports a generic `Brand` type that can be used to create branded types:

```ts
import { Brand } from "ts-brand";

type Guid = Brand<string, "guid">;

const myKnownGuid = "abc123" as Guid;
```

`ts-brand` comes with several handy utilities around branded types.
Its `make` function is particularly handy for creating a utility function that asserts a value to be a branded type.

This `asPositive` is an _"identity"_ function (one that directly returns its argument) with a return type of `UserId` instead of `number`:

```ts twoslash
import { Brand, make } from "ts-brand";

type Positive = Brand<number, "user">;

const asPositive = make<Positive>();

const value = asPositive(42);
//    ^?
```

`make` can take in an optional [type assertion function](#type-assertion-functions) to enforce provided values match some constraint.
You can use those to enforce the constraints as part of `make`'s identity functions.

This `asPositive` throws an error if the provided number isn't greater than zero:

```ts
import { Brand, make } from "ts-brand";

type Positive = Brand<number, "user">;

const asPositive = make<Positive>((value) => {
  if (value <= 0) {
    throw new Error(`Non-positive value: ${value}`);
  }
});

// Ok üëç
asPositive(42);

// Error: Non-positive value: -1 üëé
asPositive(-1);
```

See the [`ts-brand` API docs](https://github.com/kourge/ts-brand#api) for more details.

### Effect TS

[Effect](https://github.com/Effect-TS/effect) is a popular framework for building type-rich TypeScript applications.
One of the many utilities it provides is a `Brand` including:

- `Brand.Brand`: a generic type that acts as the brand in a type
- `Brand.nominal`: a generic function that returns a type brand identify function

Put together, the two allow making type brands similar to `ts-brand`:

```ts twoslash
// @errors: 2322
import { Brand } from "effect";

type Positive = number & Brand.Brand<"Positive">;

const asPositive = Brand.nominal<Positive>();

let myPositive: Positive;

// Ok: the asPositive tells TypeScript we meant this. üëç
myPositive = asPositive(123);

// Type error: TypeScript doesn't know whether this is intended.
myPositive = 123;
```

`Effect` also allows making a type brand assertion function.
Unlike `ts-brand`'s `make`, `Effect` provides a separate function, `Brand.refined`, that takes in two parameters:

1. A function that determines whether a value matches the type brand's constraint
2. A function to throw an error for a value that doesn't match the constraint

This `asPositive` throws an error if the provided number isn't greater than zero:

```ts twoslash
// @errors: 2322
import { Brand } from "effect";

type Positive = number & Brand.Brand<"Positive">;

const asPositive = Brand.refined<Positive>(
  (value) => value > 0,
  (value) => Brand.error(`Non-positive value: ${value}`)
);

// Ok üëç
asPositive(42);

// Error: Non-positive value: -1 üëé
asPositive(-1);
```

See [Effect's Branded Types docs](https://effect.website/docs/guides/style/branded-types) for more details.

## Alternatives to Type Brands

TODO

### Avoiding Type Brands Altogether

TODO

### Discriminated Unions

TODO

### Enums

TODO

### Template Literal Strings

TODO

## Further Reading

- Narrowing is covered in [_Learning TypeScript_ Chapter 3: Unions and Literals](https://www.learningtypescript.com/unions-and-literals).
- Object types and discriminated unions are covered in [_Learning TypeScript_ Chapter 4: Objects](https://www.learningtypescript.com/objects).
- Type predicates are covered in [_Learning TypeScript_ Chapter 9: Type Modifiers](https://www.learningtypescript.com/type-modifiers).
- Generic functions are covered in [_Learning TypeScript_ Chapter 10: Generics](https://www.learningtypescript.com/generics).

---

Got your own TypeScript questions?
Tweet [@LearningTSBook](https://twitter.com/LearningTSBook) and the answer might become an article too!
