---
date: "February 17 2023"
description: "Why TypeScript's type narrowing doesn't apply to object properties that have just been created."
meta: literals, narrowing, objects, primitives
---

# Why Object Properties Aren't Narrowed Before Usage

TypeScript's type system boasts a powerful trio of features called _primitives_, _literals_, and _union types_:

- _Primitives_ are types representing the basic immutable value types from JavaScript: `boolean`, `number`, `string`, etc.
- _Literals_ are types representing specific instances of primitives: `true`, `123`, `"abc"`, etc.
- _Union types_ are types representing values that could be one of several possible types, such as `string | undefined` representing a value that can be `string` or `undefined`.

> You can think of each _primitive_ as being a _union_ of all the _literals_ of that type.

When you create an object in a TypeScript file, TypeScript's type system needs to figure out what type the object's properties are allowed to be.
TypeScript will by default use _primitive_ types _(`number`, `string`, ...)_ instead of _literal_ types _(`123`, `"abc"`, ...)_ for properties with a literal value.

For example, `counts.zucchini` in this object is considered to be type `number`, not `2`:

```ts twoslash
const counts = {
  apple: 1,
  zucchini: 2,
};

counts.zucchini;
//     ^?
```

Shouldn't TypeScript know that `counts.zucchini` starts off as the specific literal type `2`, not the general primitive type `number`?
Can't it tell we haven't changed the object yet?

It can't, but it won't.
And for very good reason.

<!--truncate-->

## Change Tracking is Impractical

The problem is that it's difficult -oftentimes impossible- for TypeScript to know whether an object has been modified if anything has happened between its initialization and first usage.
If the object is used in any meaningful application logic, TypeScript won't be able to tell whether it was modified.

### A Practical Example

Let's say you want to `console.log` the `counts` object before reassigning a new value to a count.
Your use your own custom `log` function that just so happens to only call `console.log`?
You'd still want `counts.zucchini` to be `2` after `log(counts);`, right?

```ts
function log(data: unknown) {
  console.log(data);
}

const counts = {
  apple: 1,
  zucchini: 2,
};

log(counts);

// You'd want this to be 2, right?
counts.zucchini;
```

Unfortunately, it could become quite difficult for TypeScript to reliably determine whether the `log` function modifies its `data` parameter.
The code in this snippet was only one line - but what if the function provides `counts` to potentially several other functions?
What if those functions are only declared in `.d.ts` files that don't describe the contents of the functions?

```ts
// Defined as:
// function someFancyFunction(data: Record<string, string>): void;
import { someFancyFunction } from "@joshuakgoldberg/some-fancy-library";

// Does this mutate `data`? Heck if we know! ðŸ¤·
function log(data: Record<string, string>) {
  someFancyFunction(data);
}
```

In theory, the `log` function could use the `readonly` operator on its `data` parameter to indicate that `data` is never modified.
But adding `readonly`s all over is inconvenient.
Many community-written type definitions don't properly mark parameters as read-only.
Even `console.log` isn't marked as having read-only parameters as of TypeScript 5's built-in type definitions.

## A Compromise For Consistency

As a result, TypeScript's type system has the intentional

## Further Reading

A legendary [Trade-offs in Control Flow Analysis](https://github.com/microsoft/TypeScript/issues/9998) issue exists in the TypeScript repository.
It describes many more common trade-offs in how the TypeScript type checker analyzes the flow of values.
It's a great read if you're interested in understanding more of the edge cases around object properties and type narrowing.
